{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts", "../../../../../../../../../node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts", "../../../../../../../../../node_modules/next/src/lib/scheduler.ts", "../../../../../../../../../node_modules/next/src/server/request/cookies.ts", "../../../../../../../../../node_modules/next/src/server/web/spec-extension/adapters/headers.ts", "../../../../../../../../../node_modules/next/src/server/request/headers.ts", "../../../../../../../../../node_modules/next/src/server/request/draft-mode.ts", "../../../../../../../../../node_modules/next/headers.js"],
  "sourcesContent": ["import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport {\n  getExpectedRequestStore,\n  type RequestStore,\n} from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function wrapWithMutableAccessCheck(\n  responseCookies: ResponseCookies\n): ResponseCookies {\n  const wrappedCookies = new Proxy(responseCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable('cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable('cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(callingExpression: string) {\n  const requestStore = getExpectedRequestStore(callingExpression)\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n", "import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n", "export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = <T = void>(cb: ScheduledFn<T>): void => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = <T = void>(cb: ScheduledFn<T>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n", "import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the cookies object.\n        return makeDynamicallyTrackedExoticCookies(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how cookies has worked in PPR without dynamicIO.\n        postponeWithTracking(\n          workStore.route,\n          callingExpression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We track dynamic access here so we don't need to wrap the cookies in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration(\n          callingExpression,\n          workStore,\n          workUnitStore\n        )\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using cookies inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  // cookies is being called in a dynamic context\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  let underlyingCookies: ReadonlyRequestCookies\n\n  if (areCookiesMutableInCurrentPhase(requestStore)) {\n    // We can't conditionally return different types here based on the context.\n    // To avoid confusion, we always return the readonly type here.\n    underlyingCookies =\n      requestStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n  } else {\n    underlyingCookies = requestStore.cookies\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticCookiesWithDevWarnings(\n      underlyingCookies,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticCookies(underlyingCookies)\n  }\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeDynamicallyTrackedExoticCookies(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`cookies()[Symbol.iterator]()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    size: {\n      get() {\n        const expression = '`cookies().size`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = new Promise<ReadonlyRequestCookies>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingCookies))\n  )\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...cookies()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = '`cookies().size`'\n        syncIODev(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        syncIODev(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()` or implicit casting'\n        syncIODev(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(createCookiesAccessError)\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n", "import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n", "import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\n\n/**\n * In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance\n * synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedHeaders = ReadonlyHeaders\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedExoticHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the headers object.\n        return makeDynamicallyTrackedExoticHeaders(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how headers has worked in PPR without dynamicIO.\n        // TODO consider switching the semantic to throw on property access instead\n        postponeWithTracking(\n          workStore.route,\n          'headers',\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We are in a legacy static generation mode while prerendering\n        // We track dynamic access here so we don't need to wrap the headers in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration('headers', workStore, workUnitStore)\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using headers inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  const requestStore = getExpectedRequestStore('headers')\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticHeadersWithDevWarnings(\n      requestStore.headers,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticHeaders(requestStore.headers)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeDynamicallyTrackedExoticHeaders(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`headers()[Symbol.iterator]()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: underlyingHeaders.append.bind(underlyingHeaders),\n    },\n    delete: {\n      value: underlyingHeaders.delete.bind(underlyingHeaders),\n    },\n    get: {\n      value: underlyingHeaders.get.bind(underlyingHeaders),\n    },\n    has: {\n      value: underlyingHeaders.has.bind(underlyingHeaders),\n    },\n    set: {\n      value: underlyingHeaders.set.bind(underlyingHeaders),\n    },\n    getSetCookie: {\n      value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),\n    },\n    forEach: {\n      value: underlyingHeaders.forEach.bind(underlyingHeaders),\n    },\n    keys: {\n      value: underlyingHeaders.keys.bind(underlyingHeaders),\n    },\n    values: {\n      value: underlyingHeaders.values.bind(underlyingHeaders),\n    },\n    entries: {\n      value: underlyingHeaders.entries.bind(underlyingHeaders),\n    },\n    [Symbol.iterator]: {\n      value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = new Promise<ReadonlyHeaders>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingHeaders))\n  )\n\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.append.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.delete.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.getSetCookie.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        syncIODev(route, expression)\n        return underlyingHeaders.forEach.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.values.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.entries.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...headers()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingHeaders[Symbol.iterator].apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'string' ? `'${arg}'` : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(createHeadersAccessError)\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\ntype HeadersExtensions = {\n  [K in keyof ReadonlyHeaders]: unknown\n}\n", "import { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\n\n/**\n * In this version of Next.js `draftMode()` returns a Promise however you can still reference the properties of the underlying draftMode object\n * synchronously to facilitate migration. The `UnsafeUnwrappedDraftMode` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `draftMode()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedDraftMode` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `draftMode()` value can be awaited or you should call `draftMode()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedDraftMode` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `draftMode()` will only return a Promise and you will not be able to access the underlying draftMode object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedDraftMode` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedDraftMode = DraftMode\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache' ||\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      // Return empty draft mode\n      if (\n        process.env.NODE_ENV === 'development' &&\n        !workStore?.isPrefetchRequest\n      ) {\n        const route = workStore?.route\n        return createExoticDraftModeWithDevWarnings(null, route)\n      } else {\n        return createExoticDraftMode(null)\n      }\n    }\n  }\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  const cachedDraftMode = CachedDraftModes.get(requestStore.draftMode)\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  let promise\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    promise = createExoticDraftModeWithDevWarnings(\n      requestStore.draftMode,\n      route\n    )\n  } else {\n    promise = createExoticDraftMode(requestStore.draftMode)\n  }\n  CachedDraftModes.set(requestStore.draftMode, promise)\n  return promise\n}\n\ninterface CacheLifetime {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createExoticDraftMode(\n  underlyingProvider: null | DraftModeProvider\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      return instance.isEnabled\n    },\n    set(newValue) {\n      Object.defineProperty(promise, 'isEnabled', {\n        value: newValue,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    enumerable: true,\n    configurable: true,\n  })\n  ;(promise as any).enable = instance.enable.bind(instance)\n  ;(promise as any).disable = instance.disable.bind(instance)\n\n  return promise\n}\n\nfunction createExoticDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      const expression = '`draftMode().isEnabled`'\n      syncIODev(route, expression)\n      return instance.isEnabled\n    },\n    set(newValue) {\n      Object.defineProperty(promise, 'isEnabled', {\n        value: newValue,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    enumerable: true,\n    configurable: true,\n  })\n\n  Object.defineProperty(promise, 'enable', {\n    value: function get() {\n      const expression = '`draftMode().enable()`'\n      syncIODev(route, expression)\n      return instance.enable.apply(instance, arguments as any)\n    },\n  })\n\n  Object.defineProperty(promise, 'disable', {\n    value: function get() {\n      const expression = '`draftMode().disable()`'\n      syncIODev(route, expression)\n      return instance.disable.apply(instance, arguments as any)\n    },\n  })\n\n  return promise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We we have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()')\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()')\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst noop = () => {}\n\nconst warnForSyncAccess = process.env.__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS\n  ? noop\n  : createDedupedByCallsiteServerErrorLoggerDev(createDraftModeAccessError)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string) {\n  const store = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (store) {\n    // We we have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      } else if (workUnitStore.phase === 'after') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n        )\n      }\n    }\n\n    if (store.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        const error = new Error(\n          `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n        )\n        abortAndThrowOnSynchronousRequestDataAccess(\n          store.route,\n          expression,\n          error,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender\n        postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // legacy Prerender\n        workUnitStore.revalidate = 0\n\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      } else if (\n        process.env.NODE_ENV === 'development' &&\n        workUnitStore &&\n        workUnitStore.type === 'request'\n      ) {\n        workUnitStore.usedDynamic = true\n      }\n    }\n  }\n}\n", "module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n"],
  "mappings": "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",
  "names": ["MutableRequestCookiesAdapter", "ReadonlyRequestCookiesError", "RequestCookiesAdapter", "appendMutableCookies", "areCookiesMutableInCurrentPhase", "getModifiedCookieValues", "responseCookiesToRequestCookies", "wrapWithMutableAccessCheck", "Error", "constructor", "callable", "seal", "cookies", "Proxy", "get", "target", "prop", "receiver", "ReflectAdapter", "SYMBOL_MODIFY_COOKIE_VALUES", "Symbol", "for", "modified", "Array", "isArray", "length", "headers", "mutableCookies", "modifiedCookieValues", "resCookies", "ResponseCookies", "returnedCookies", "getAll", "cookie", "set", "wrap", "onUpdateCookies", "responseCookies", "Headers", "modifiedValues", "modifiedCookies", "Set", "updateResponseCookies", "workStore", "workAsyncStorage", "getStore", "pathWasRevalidated", "allCookies", "filter", "c", "has", "name", "serializedCookies", "tempCookies", "push", "toString", "wrappedCookies", "args", "add", "delete", "ensureCookiesAreStillMutable", "requestStore", "phase", "callingExpression", "getExpectedRequestStore", "requestCookies", "RequestCookies", "createDedupedByCallsiteServerErrorLoggerDev", "errorRef", "current", "cache", "React", "fn", "logErrorOrWarn", "process", "env", "__NEXT_DYNAMIC_IO", "console", "error", "warn", "flushCurrentErrorIfNew", "key", "getMessage", "logDedupedError", "args", "message", "callStackFrames", "Error", "stack", "split", "undefined", "length", "atLeastOneTask", "scheduleImmediate", "scheduleOnNextTick", "waitAtLeastOneReactRenderTask", "cb", "Promise", "resolve", "then", "process", "env", "NEXT_RUNTIME", "setTimeout", "nextTick", "setImmediate", "r", "cookies", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "phase", "isRequestAPICallableInsideAfter", "Error", "route", "forceStatic", "underlyingCookies", "createEmptyCookies", "makeUntrackedExoticCookies", "type", "dynamicShouldError", "StaticGenBailoutError", "makeDynamicallyTrackedExoticCookies", "postponeWithTracking", "dynamicTracking", "throwToInterruptStaticGeneration", "trackDynamicDataInDynamicRender", "requestStore", "getExpectedRequestStore", "areCookiesMutableInCurrentPhase", "userspaceMutableCookies", "isPrefetchRequest", "makeUntrackedExoticCookiesWithDevWarnings", "RequestCookiesAdapter", "seal", "RequestCookies", "Headers", "CachedCookies", "WeakMap", "prerenderStore", "cachedPromise", "get", "promise", "makeHangingPromise", "renderSignal", "set", "Object", "defineProperties", "Symbol", "iterator", "value", "expression", "error", "createCookiesAccessError", "abortAndThrowOnSynchronousRequestDataAccess", "size", "arguments", "length", "describeNameArg", "getAll", "has", "arg", "delete", "clear", "toString", "cachedCookies", "Promise", "resolve", "bind", "polyfilledResponseCookiesIterator", "polyfilledResponseCookiesClear", "scheduleImmediate", "syncIODev", "apply", "call", "writable", "name", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "warnForSyncAccess", "noop", "process", "env", "__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS", "createDedupedByCallsiteServerErrorLoggerDev", "prefix", "map", "c", "values", "returnable", "cookie", "HeadersAdapter", "ReadonlyHeadersError", "Error", "constructor", "callable", "Headers", "headers", "Proxy", "get", "target", "prop", "receiver", "ReflectAdapter", "lowercased", "toLowerCase", "original", "Object", "keys", "find", "o", "set", "value", "has", "deleteProperty", "seal", "merge", "Array", "isArray", "join", "from", "append", "name", "existing", "push", "delete", "forEach", "callbackfn", "thisArg", "entries", "call", "key", "values", "Symbol", "iterator", "headers", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "phase", "isRequestAPICallableInsideAfter", "Error", "route", "forceStatic", "underlyingHeaders", "HeadersAdapter", "seal", "Headers", "makeUntrackedExoticHeaders", "type", "dynamicShouldError", "StaticGenBailoutError", "makeDynamicallyTrackedExoticHeaders", "postponeWithTracking", "dynamicTracking", "throwToInterruptStaticGeneration", "trackDynamicDataInDynamicRender", "requestStore", "getExpectedRequestStore", "isPrefetchRequest", "makeUntrackedExoticHeadersWithDevWarnings", "CachedHeaders", "WeakMap", "prerenderStore", "cachedHeaders", "get", "promise", "makeHangingPromise", "renderSignal", "set", "Object", "defineProperties", "append", "value", "expression", "describeNameArg", "arguments", "error", "createHeadersAccessError", "abortAndThrowOnSynchronousRequestDataAccess", "delete", "_delete", "has", "getSetCookie", "forEach", "keys", "values", "entries", "Symbol", "iterator", "Promise", "resolve", "bind", "scheduleImmediate", "syncIODev", "apply", "arg", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "warnForSyncAccess", "noop", "process", "env", "__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS", "createDedupedByCallsiteServerErrorLoggerDev", "prefix", "draftMode", "callingExpression", "workStore", "workAsyncStorage", "getStore", "workUnitStore", "workUnitAsyncStorage", "type", "isPrefetchRequest", "route", "createExoticDraftModeWithDevWarnings", "createExoticDraftMode", "requestStore", "getExpectedRequestStore", "cachedDraftMode", "CachedDraftModes", "get", "promise", "set", "WeakMap", "underlyingProvider", "instance", "DraftMode", "Promise", "resolve", "Object", "defineProperty", "isEnabled", "newValue", "value", "writable", "enumerable", "configurable", "enable", "bind", "disable", "expression", "syncIODev", "apply", "arguments", "constructor", "provider", "_provider", "trackDynamicDraftMode", "prerenderPhase", "trackSynchronousRequestDataAccessInDev", "warnForSyncAccess", "noop", "process", "env", "__NEXT_DISABLE_SYNC_DYNAMIC_API_WARNINGS", "createDedupedByCallsiteServerErrorLoggerDev", "createDraftModeAccessError", "prefix", "Error", "store", "phase", "dynamicShouldError", "StaticGenBailoutError", "error", "abortAndThrowOnSynchronousRequestDataAccess", "postponeWithTracking", "dynamicTracking", "revalidate", "err", "DynamicServerError", "dynamicUsageDescription", "dynamicUsageStack", "stack", "usedDynamic", "require_headers"]
}
